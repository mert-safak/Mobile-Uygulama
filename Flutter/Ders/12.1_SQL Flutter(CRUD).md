# SQL Flutter İçerisinde Kullanımı
## Kütüphane Kurulumu
dependecies altına path: ve altına sqflite: yazılır. Girintilere dikkat edilir. Yazım bitince pub get denilir.
```yaml
dependencies:
  dependencies:
  flutter:
    sdk: flutter
  flutter_bloc:
  path:
  sqflite:
```
## veritabani_yardimcisi oluşturma ve Gerekli Ön İşlemler
Öncelikle uygulamanın ismine(en üste) sağ tıklanıp bir directory oluşturulup isim verilir örneğin: veritabani. DBbrowser ile önceden oluşturduğumuz veritabanını buradaki veritabani klasörüne kopyalıyoruz. Daha sonra lib içerisinde sqlite isimli bir directory oluşturulur. Daha sonra ise veritabani_yardimcisi.dart isimli bir dart file oluşturulur. Bunun içerisine aşağıdaki kod yazılır. Importlar karışabiliyor yanlış importlar gelebiliyor olduğu gibi yapıştırmak gerekebilir. Bu kod ile veritabanımız telefon içerisine kopyalanıyor. Kopya zaten var ise işlem yapmaz.
```dart
import 'dart:io';
import 'package:flutter/services.dart';
import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';

class VeritabaniYardimcisi {
  static final String veritabaniAdi = "rehber.sqlite";

  static Future<Database> veritabaniErisim() async {
    String veritabaniYolu = join(await getDatabasesPath(),veritabaniAdi);

    if(await databaseExists(veritabaniYolu)){
      print("Veritabanı zaten var.Kopyalamaya gerek yok.");
    }else{
      ByteData data = await rootBundle.load("veritabani/$veritabaniAdi");
      List<int> bytes = data.buffer.asUint8List(data.offsetInBytes, data.lengthInBytes);
      await File(veritabaniYolu).writeAsBytes(bytes, flush: true);
      print("Veritabanı kopyalandı.");
    }
    return openDatabase(veritabaniYolu);
  }
}
```
Daha sonra ise pubspec.yaml içerisinde resimlerin vb. eklendiği kısma assets olarak veritabanımız tanıtılır.
```yaml
  assets:
    - veritabani/rehber.sqlite
```
## Veritabanını flutter içerisinden okuma
Aşağıdaki kod ile önce daorepository'deki kisileriYukle isimli bir fonksiyona db isimli değişken tanımlanır. Önceden oluşturduğumuz VeritabaniYardimcisi.veritabaniErisim ile veritabanına erişilir. İlk başta Liste şeklinde map(dart dilindeki dictionary yapısı) ile veriler çekilir. Burada key value ilişkisi vardur. Key'ler string value'ler ise farklı tipte geelebilir. Bu yüzden dynamics yazılır. db.rawQuery() ile ilgili SQL kodu yazılır.  Daha sonra ise List.generate kullanılarak çekilen verilerden Kisiler sınıfından oluşan nesneler oluşturulup listeye eklenir.
```
  Future<List<Kisiler>>kisileriYukle() async {
    var db = await VeritabaniYardimcisi.veritabaniErisim();
    List<Map<String,dynamic>> maps = await db.rawQuery("SELECT * FROM kisiler");

    return List.generate(maps.length, (index) {
      var satir = maps[index];
      return Kisiler(kisi_id: satir["kisi_id"], kisi_ad: satir["kisi_ad"], kisi_tel: satir["kisi_tel"]);
    },);
  }
```
## Veritabanına veri kaydetme
Aşağıda kaydet isimli fonskiyon kisi_id ve kisi_tel bekler veritabanında ilgili kısımda bu verileri vardır çünkü. Yine VeritabaniYardimcisi.veritabaniErisim() ile bir nesne oluşturulur. Veriler map(dictionary) tipinde kaydedildiği ve alındığı için  bu şekilde bir yeniKisi değişkeni oluşturulur. Daha sonra içerisindeki veritabanında karşılık gelen sütun isimleri key olarak alınarak value değerleri tanımlanır. Daha sonra db.insert("kisiler", yeniKisi) ile veritabanına veri eklenir. Burada kisiler tablonun ismidir. Veri ekleme işlemlerindne sonra yeni verilerin görünmesi için veriler tekrar okunmalıdır.  Daha sonra ilgili fonskiyon çağırılarak veritabanı işlemleri yapılabilir. Id'yi de zaten örneğin Kisiler classı oluştururken istiyorduk. Kod ile aşağıdaki şekilde oluşturuken de veritabanını yaparken prmimary key otomatik arttırmayı seçmiştik. O yüzden kendisi kişi kaydedince veritabanına ekleme yapıyor.
```dart
Future<void> kaydet(String kisi_ad,String kisi_tel) async {
    var db = await VeritabaniYardimcisi.veritabaniErisim();
    var yeniKisi = Map<String,dynamic>();
    yeniKisi["kisi_ad"] = kisi_ad;
    yeniKisi["kisi_tel"] = kisi_tel;
    await db.insert("kisiler", yeniKisi);
  }
```

## Veritabanındaki verileri güncelleme
Veri kaydetme fonskiyonuna çok benzer. Burada db.update içerisinde whereArgs kısmında isi_id değeri where kısmında aranır. Eğer mevcutsa o kısma güncelleme yapar. Burada önemli olan id'yi bilmektir. Id'yi de zaten örneğin Kisiler classı oluştururken istiyorduk. Kod ile oluşturuken de veritabanını yaparken otomatik arttırmayı seçmiştik. O yüzden kendisi kişi kaydedince veritabanına ekleme yapıyor.
```dart
Future<void> guncelle(int kisi_id, String kisi_ad, String kisi_tel) async {
    var db = await VeritabaniYardimcisi.veritabaniErisim();
    var guncellenenKisi = Map<String,dynamic>();
    guncellenenKisi["kisi_ad"] = kisi_ad;
    guncellenenKisi["kisi_tel"] = kisi_tel;
    await db.update("kisiler", guncellenenKisi, where: "kisi_id = ?" ,whereArgs: [kisi_id]);
  }
```

## Veritabanındaki verileri silme
Veri silmek için ise önce db nesnesi oluşturulur ve db.delete() kullanılır. Burada sadece id'yi bilmek yeterlidir.
```dart
Future<void>sil(int kisi_id) async {
    var db = await VeritabaniYardimcisi.veritabaniErisim();
    await db.delete("kisiler", where: "kisi_id = ?" ,whereArgs: [kisi_id]);
  }
```

## Veritabanında veri arama işlemi yapma
Veri okumaya çok benzer sadece sorgu kısmı değişir. Aranan harf kelime vb.'ne göre her seferinde liste oluşturulur. Arayüze de burda oluşturulan liste gider.
```dart
Future<List<Kisiler>>ara(String aramaKelimesi) async {
    var db = await VeritabaniYardimcisi.veritabaniErisim();
    List<Map<String,dynamic>> maps = await db.rawQuery("SELECT * FROM kisiler WHERE kisi_ad like '%$aramaKelimesi%'");

    return List.generate(maps.length, (index) {
      var satir = maps[index];
      return Kisiler(kisi_id: satir["kisi_id"], kisi_ad: satir["kisi_ad"], kisi_tel: satir["kisi_tel"]);
    },);
  }
```


