# SQL Flutter İçerisinde Kullanımı
## Kütüphane Kurulumu
dependecies altına path: ve altına sqflite: yazılır. Girintilere dikkat edilir. Yazım bitince pub get denilir.
```yaml
dependencies:
  dependencies:
  flutter:
    sdk: flutter
  flutter_bloc:
  path:
  sqflite:
```
## veritabani_yardimcisi oluşturma ve Gerekli Ön İşlemler
Öncelikle uygulamanın ismine(en üste) sağ tıklanıp bir directory oluşturulup isim verilir örneğin: veritabani. DBbrowser ile önceden oluşturduğumuz veritabanını buradaki veritabani klasörüne kopyalıyoruz. Daha sonra lib içerisinde sqlite isimli bir directory oluşturulur. Daha sonra ise veritabani_yardimcisi.dart isimli bir dart file oluşturulur. Bunun içerisine aşağıdaki kod yazılır. Importlar karışabiliyor yanlış importlar gelebiliyor olduğu gibi yapıştırmak gerekebilir. Bu kod ile veritabanımız telefon içerisine kopyalanıyor. Kopya zaten var ise işlem yapmaz.
```dart
import 'dart:io';
import 'package:flutter/services.dart';
import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';

class VeritabaniYardimcisi {
  static final String veritabaniAdi = "rehber.sqlite";

  static Future<Database> veritabaniErisim() async {
    String veritabaniYolu = join(await getDatabasesPath(),veritabaniAdi);

    if(await databaseExists(veritabaniYolu)){
      print("Veritabanı zaten var.Kopyalamaya gerek yok.");
    }else{
      ByteData data = await rootBundle.load("veritabani/$veritabaniAdi");
      List<int> bytes = data.buffer.asUint8List(data.offsetInBytes, data.lengthInBytes);
      await File(veritabaniYolu).writeAsBytes(bytes, flush: true);
      print("Veritabanı kopyalandı.");
    }
    return openDatabase(veritabaniYolu);
  }
}
```
Daha sonra ise pubspec.yaml içerisinde resimlerin vb. eklendiği kısma assets olarak veritabanımız tanıtılır.
```yaml
  assets:
    - veritabani/rehber.sqlite
```
## Veritabanını flutter içerisinden okuma
Aşağıdaki kod ile önce daorepository'deki kisileriYukle isimli bir fonksiyona db isimli değişken tanımlanır. Önceden oluşturduğumuz VeritabaniYardimcisi.veritabaniErisim ile veritabanına erişilir. İlk başta Liste şeklinde map(dart dilindeki dictionary yapısı) ile veriler çekilir. Burada key value ilişkisi vardur. Key'ler string value'ler ise farklı tipte geelebilir. Bu yüzden dynamics yazılır. db.rawQuery() ile ilgili SQL kodu yazılır.  Daha sonra ise List.generate kullanılarak çekilen verilerden Kisiler sınıfından oluşan nesneler oluşturulup listeye eklenir.
```
  Future<List<Kisiler>>kisileriYukle() async {
    var db = await VeritabaniYardimcisi.veritabaniErisim();
    List<Map<String,dynamic>> maps = await db.rawQuery("SELECT * FROM kisiler");

    return List.generate(maps.length, (index) {
      var satir = maps[index];
      return Kisiler(kisi_id: satir["kisi_id"], kisi_ad: satir["kisi_ad"], kisi_tel: satir["kisi_tel"]);
    },);
  }
```
